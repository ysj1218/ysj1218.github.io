1. 网页生成的过程：
	(1) HTML代码转化成DOM
	(2) CSS代码转化成CSSOM
	(3) 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
	(4) 生成布局（layout），即将所有渲染树的所有节点进行平面合成
	(5) 将布局绘制（paint）在屏幕上
	
	请求url --> 浏览器对url进行解析 --> 服务器进行响应，后端排出一个页面显示  --> 加载css文件 --> 加载完成返回给浏览器，浏览器对页面进行渲染  --> 然后加载js文件
	
2. 重排和重绘：
	网页生成的时候至少会渲染一次，用户访问的过程中还会不断重新渲染。以下三种情况会导致页面重新渲染：需要重新生成布局【重排】和重新绘制【重绘】 
		(1) 修改DOM
		(2) 修改样式表
		(3) 用户事件
		
	重绘不一定需要重排，比如改变某个网页元素的颜色，就只会触发重绘，不会触发重排，因为布局没有改变。但是重排一定触发重绘，比如改变网页元素的位置，就会同时触发重绘和重排，因为布局改变。
	重绘和重排会不断地触发，不可避免，但是很耗费资源，导致网页性能低。要提高网页性能，就要降低重排和重绘的频率和成本，尽量少触发重新渲染。
		降低浏览器重新渲染的频率和成本：
			(1) DOM的多个读操作放在一起，多个写操作放在一起，不要两个读操作之间加入一个写操作。
			(2) 不要一条条的改变样式，而要通过class或者csstext属性，一次性的改变样式。
			(3) 缓存结果。
			(4) 尽量使用离线DOM，而不是真实的网页DOM，来改变元素样式。比如可以使用文档碎片Fragment对象。  var fragment = document.createDocumentFragment();
			(5) 先将元素设为display:none;(需要一次重排和重绘)  然后对这个节点进行100次操作，最后再恢复显示(需要一次重排和重绘)。 这样一来就用两次重新渲染取代了可能高达100次的重新渲染。
			(6) position属性为absolute或者fixed的元素，重排的开销会比较小，因为不用考虑他对其他元素的影响。
			(7)	只在必要的时候才将元素的display属性为可见，因为不可见的元素不影响重排和重绘，另外visibility:hidden;的元素只对重绘有影响，不影响重排。
			(8) 使用虚拟DOM的脚本库，比如React.
			(9) 使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染
	
	网页性能优化：
		(1) 减少http请求，合理设置http缓存。
			http缓存机制与原理：
				HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。
				浏览器向服务器请求数据，发送请求报文，服务器向浏览器返回数据，返回响应报文。
				报文信息主要分为两部分：
					包含属性的首部(header) --->  附加信息（cookie， 缓存信息等） 与缓存相关的规则信息均包含在header中
					包含数据的主体(body)   --->  http请求真正想要传输的部分
				
				缓存规则解析：
					在客户端第一次请求数据时，此时缓存数据库中还没有对应的缓存数据，需要请求服务器，服务器返回数据和缓存规则后将数据和缓存规则存储至缓存数据库中。
					http缓存有多种规则，根据是否需要重新向服务器发起请求来分类，可以分为两大类：强制缓存，对比缓存。
						强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效都会和服务器发生交互。两类缓存机制可以同时存在，强制缓存优先级高于对比缓存。当执行强制缓存的规则时，
						如果缓存有效，直接使用缓存，不再执行对比缓存规则。
					
						强制缓存:
							当没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应头上。对于强制缓存，响应header中会有两个字段来标明失效规则：Cache-Control和Expires
								Expires：
									expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间的话，就直接使用缓存数据。
								Cache-Control：
									常见的取值有：private public no-cache max-age no-store，默认为private
									private：客户端可以缓存
									public：客户端和代理服务器都可缓存
									max-age=xxx：缓存的内容将在xxx秒后失效
									no-cache：需要使用对比缓存来验证缓存数据
									no-store：所有内容都不会缓存，强制缓存，对比缓存都不会触发。
									
						对比缓存: 需要进行比较判断是否可以使用缓存。
							当浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将两者备份至缓存数据库中。
							再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后返回304，通知客户端比较成功，可以使用缓存数据。
							
							缓存标识在请求header和响应header之间传递：分为两种标识 Last-Modified   If-Modified-Since
								Last-Modified
									服务器在响应请求时，告诉浏览器资源的最后修改时间
								If-Modified-Since
									再次请求服务器时，通过该字段通知服务器上次请求时，服务器返回的资源最后修改时间。服务器接受请求后发现有If-Modified-Since头存在，
									则与浏览器资源的最后修改时间进行对比，如果时间大于资源修改的最后时间，则说明最近一段时间修改过资源，则返回请求状态码200，否则则
									说明没有修改过，返回状态码304，直接走缓存。
								Etag
									服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识。
								If-None-Match
									服务器进行响应时发现有If-None-Match存在，则与请求资源的唯一标识进行对比，如果相同则说明没有修改过，返回状态码304，否则返回200
					
					对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
					对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。
					
		(2) 使用浏览器缓存。通过设置请求头中的cache-control 和 express。
		(3) 启用压缩。在服务器端对文件进行压缩，浏览器端对文件解压缩，可有效的减少通信传输的信息量。
		(4) css精灵图。
		(5) 懒加载。在页面刚加载时之家爱第一屏，当用户继续往后滚屏才加载后续的图片。
		(6) css放在页面上部header，js放在页面底部。
		(7) 异步请求callback。
		(8) 减少cookie传输。对于静态的资源访问可以考虑使用独立域名访问，避免请求静态资源时发送cookie。
		(9) js代码进行优化：
			DOM
			慎用with
			避免使用eval和Function构造函数
			减少作用域链查找
			减少闭包的使用
			字符串拼接 join()
		(10) css选择符优化  对css选择符的解析是从右向左进行的。   
		(11) CDN加速。   
		(12) 反向代理。传统代理服务器位于浏览器一侧，代理浏览器将http请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站web服务器接收http请求。